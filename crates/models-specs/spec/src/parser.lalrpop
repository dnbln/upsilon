use std::rc::Rc;

use crate::ast::*;
use crate::keywords::*;
use crate::punct::*;
use crate::span::*;

grammar<'span_hosts> (span_hosts: &'span_hosts Rc<SpanHosts>);

ConstToken<V, T>: T =
   <start: @L> V <end: @R> =>
       Span::new(TextSize::new(start), TextSize::new(end), Rc::clone(span_hosts)).into();

Kw<V, T>: T = ConstToken<V, T>;

Punct<V, T>: T = ConstToken<V, T>;

Ident: Ident = {
    <start: @L> <value: r"[a-zA-Z_][a-zA-Z0-9_]*"> <end: @R> => Ident::new(value.to_string(), Span::new(TextSize::new(start), TextSize::new(end), Rc::clone(span_hosts))),
};
OpenParen: OpenParenPunctToken = Punct<"(", OpenParen>;
CloseParen: CloseParenPunctToken = Punct<")", CloseParen>;
OpenBracket: OpenBracketPunctToken = Punct<"[", OpenBracket>;
CloseBracket: CloseBracketPunctToken = Punct<"]", CloseBracket>;
OpenAngleBracket: OpenAngleBracketPunctToken = Punct<"<", OpenAngleBracket>;
CloseAngleBracket: CloseAngleBracketPunctToken = Punct<">", CloseAngleBracket>;
OpenBrace: OpenBracePunctToken = Punct<"{", OpenBrace>;
CloseBrace: CloseBracePunctToken = Punct<"}", CloseBrace>;
Colon: ColonPunctToken = Punct<":" , Colon>;
Comma: CommaPunctToken = Punct<"," , Comma>;
Dot: DotPunctToken = Punct<"." , Dot>;
QMark: QMarkPunctToken = Punct<"?" , QMark>;
Eq: EqPunctToken = Punct<"=" , Eq>;
Semicolon: SemicolonPunctToken = Punct<";" , Semicolon>;
HashSymbol: HashPunctToken = Punct<"#", HashSymbol>;


PackageKw: PackageKw = Kw<"package", PackageKw>;
NewtypeKw: NewtypeKw = Kw<"newtype", NewtypeKw>;
StructKw: StructKw = Kw<"struct", StructKw>;
EnumKw: EnumKw = Kw<"enum", EnumKw>;


pub(crate) File: AstFile = {
    Package* => AstFile::new(<>, Rc::clone(span_hosts)),
}

PackageItem: PackageItem = {
    <struct_: Struct> => PackageItem::Struct(struct_),
    <newtype_struct: NewtypeStruct> => PackageItem::NewtypeStruct(newtype_struct),
    <enum_: Enum> => PackageItem::Enum(enum_),
    <package: Package> => PackageItem::Package(package),
};

Struct: Struct = {
    <attrs: Attrs>
    <struct_kw: StructKw> <name: Ident> <open_brace: OpenBrace>
        <fields: (<StructField> Comma)*>
    <close_brace: CloseBrace> => Struct::new(attrs, struct_kw, name, open_brace, fields, close_brace),
};

NewtypeStruct: NewtypeStruct = {
    <attrs: Attrs>
    <newtype_kw: NewtypeKw>
    <open_angle_bracket: OpenAngleBracket>
        <ty: TyRef>
    <close_angle_bracket: CloseAngleBracket>
    <struct_kw: StructKw> <name: Ident> <semicolon: Semicolon> =>
        NewtypeStruct::new(
            attrs,
            newtype_kw,
            open_angle_bracket,
            ty,
            close_angle_bracket,
            struct_kw,
            name,
            semicolon,
        ),
};

Enum: Enum = {
    <attrs: Attrs>
    <enum_kw: EnumKw> <ident: Ident> <open_brace: OpenBrace>
        <variants: (<EnumVariant> Comma)*>
    <close_brace: CloseBrace> => Enum::new(attrs, enum_kw, ident, open_brace, variants, close_brace),
};

EnumVariant: EnumVariant = {
    <attrs: Attrs>
    <name: Ident> <colon: Colon> <ty: TyRef> => EnumVariant::new(attrs, name, colon, ty),
};

Attrs: Attrs = <attrs: Attr*> => Attrs::new(attrs);

TyRef: TyRef = {
    <path: Path> <generics: TyGenerics?> => TyRef::new(path, generics),
}

Path: Path = {
    <start: Path> <dot: Dot> <ident: Ident> => Path::new_path(start, dot, ident),
    <ident: Ident> => Path::new_ident(ident),
}

TyGenerics: TyGenerics = {
    <open_bracket: OpenAngleBracket> <ty: (<TyRef> Comma)*> <close_bracket: CloseAngleBracket> => TyGenerics::new(open_bracket, ty, close_bracket),
}

StructField: StructField = {
    <attrs: Attrs>
    <ident: Ident> <qmark: QMark?> <colon: Colon> <ty: TyRef> => StructField::new(attrs, ident, qmark, colon, ty),
};

Attr: Attr = {
    <hash_symbol: HashSymbol> <open_bracket: OpenBracket>
    <meta: AttrMeta> <close_bracket: CloseBracket> => Attr::new(hash_symbol, open_bracket, meta, close_bracket),
};

AttrMeta: AttrMeta = {
    <ident: Ident> => AttrMeta::Ident(ident),
    <ident: Ident> <open_paren: OpenParen>
        <meta_list: AttrMeta*>
    <close_paren: CloseParen> => AttrMeta::Parenthesized(ident, open_paren, meta_list, close_paren),
    <ident: Ident> <eq: Eq> <lit: Literal> => AttrMeta::NameValue(ident, eq, lit),
};

Package: Package = {
    PackageKw Ident OpenBrace
        PackageItem*
    CloseBrace => Package::new(<>),
}

Literal: Literal = {
    <start: @L> <value: LiteralValue> <end: @R> => Literal::new(value, Span::new(TextSize::new(start), TextSize::new(end), Rc::clone(span_hosts))),
}

LiteralValue: LiteralValue = {
    <value: r"-?[0-9]+"> => LiteralValue::Integer(value.parse().unwrap()),
    <value: r#"".*""#> => LiteralValue::String(value.to_string()),
    <value: r###"r##"""[.\n]*"""##"###> => LiteralValue::String(value.to_string()),
};